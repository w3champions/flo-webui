/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.15.6
 * source: game.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./google/protobuf/wrappers";
import * as dependency_2 from "./google/protobuf/timestamp";
import * as dependency_3 from "./player";
import * as dependency_4 from "./node";
import * as pb_1 from "google-protobuf";
export namespace game {
    export enum SlotStatus {
        SlotStatusOpen = 0,
        SlotStatusClosed = 1,
        SlotStatusOccupied = 2
    }
    export enum Race {
        RaceHuman = 0,
        RaceOrc = 1,
        RaceNightElf = 2,
        RaceUndead = 3,
        RaceRandom = 4
    }
    export enum Computer {
        ComputerEasy = 0,
        ComputerNormal = 1,
        ComputerInsane = 2
    }
    export enum SlotClientStatus {
        SlotClientStatusPending = 0,
        SlotClientStatusConnected = 1,
        SlotClientStatusLoading = 2,
        SlotClientStatusLoaded = 3,
        SlotClientStatusDisconnected = 4,
        SlotClientStatusLeft = 5
    }
    export enum GameStatus {
        GameStatusPreparing = 0,
        GameStatusCreated = 1,
        GameStatusRunning = 2,
        GameStatusEnded = 3,
        GameStatusPaused = 4,
        GameStatusTerminated = 5
    }
    export class Game extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            id?: number;
            name?: string;
            status?: GameStatus;
            map?: Map;
            slots?: Slot[];
            node?: dependency_4.node.Node;
            is_private?: boolean;
            secret?: dependency_1.google.protobuf.Int32Value;
            is_live?: boolean;
            num_players?: number;
            max_players?: number;
            random_seed?: number;
            created_by?: dependency_3.player.PlayerRef;
            started_at?: dependency_2.google.protobuf.Timestamp;
            ended_at?: dependency_2.google.protobuf.Timestamp;
            created_at?: dependency_2.google.protobuf.Timestamp;
            updated_at?: dependency_2.google.protobuf.Timestamp;
            mask_player_names?: boolean;
            game_version?: dependency_1.google.protobuf.StringValue;
            enable_ping_equalizer?: boolean;
            flo_tv_delay_override_secs?: dependency_1.google.protobuf.Int32Value;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [5], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("status" in data && data.status != undefined) {
                    this.status = data.status;
                }
                if ("map" in data && data.map != undefined) {
                    this.map = data.map;
                }
                if ("slots" in data && data.slots != undefined) {
                    this.slots = data.slots;
                }
                if ("node" in data && data.node != undefined) {
                    this.node = data.node;
                }
                if ("is_private" in data && data.is_private != undefined) {
                    this.is_private = data.is_private;
                }
                if ("secret" in data && data.secret != undefined) {
                    this.secret = data.secret;
                }
                if ("is_live" in data && data.is_live != undefined) {
                    this.is_live = data.is_live;
                }
                if ("num_players" in data && data.num_players != undefined) {
                    this.num_players = data.num_players;
                }
                if ("max_players" in data && data.max_players != undefined) {
                    this.max_players = data.max_players;
                }
                if ("random_seed" in data && data.random_seed != undefined) {
                    this.random_seed = data.random_seed;
                }
                if ("created_by" in data && data.created_by != undefined) {
                    this.created_by = data.created_by;
                }
                if ("started_at" in data && data.started_at != undefined) {
                    this.started_at = data.started_at;
                }
                if ("ended_at" in data && data.ended_at != undefined) {
                    this.ended_at = data.ended_at;
                }
                if ("created_at" in data && data.created_at != undefined) {
                    this.created_at = data.created_at;
                }
                if ("updated_at" in data && data.updated_at != undefined) {
                    this.updated_at = data.updated_at;
                }
                if ("mask_player_names" in data && data.mask_player_names != undefined) {
                    this.mask_player_names = data.mask_player_names;
                }
                if ("game_version" in data && data.game_version != undefined) {
                    this.game_version = data.game_version;
                }
                if ("enable_ping_equalizer" in data && data.enable_ping_equalizer != undefined) {
                    this.enable_ping_equalizer = data.enable_ping_equalizer;
                }
                if ("flo_tv_delay_override_secs" in data && data.flo_tv_delay_override_secs != undefined) {
                    this.flo_tv_delay_override_secs = data.flo_tv_delay_override_secs;
                }
            }
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set id(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get status() {
            return pb_1.Message.getFieldWithDefault(this, 3, GameStatus.GameStatusPreparing) as GameStatus;
        }
        set status(value: GameStatus) {
            pb_1.Message.setField(this, 3, value);
        }
        get map() {
            return pb_1.Message.getWrapperField(this, Map, 4) as Map;
        }
        set map(value: Map) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get has_map() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get slots() {
            return pb_1.Message.getRepeatedWrapperField(this, Slot, 5) as Slot[];
        }
        set slots(value: Slot[]) {
            pb_1.Message.setRepeatedWrapperField(this, 5, value);
        }
        get node() {
            return pb_1.Message.getWrapperField(this, dependency_4.node.Node, 6) as dependency_4.node.Node;
        }
        set node(value: dependency_4.node.Node) {
            pb_1.Message.setWrapperField(this, 6, value);
        }
        get has_node() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get is_private() {
            return pb_1.Message.getFieldWithDefault(this, 7, false) as boolean;
        }
        set is_private(value: boolean) {
            pb_1.Message.setField(this, 7, value);
        }
        get secret() {
            return pb_1.Message.getWrapperField(this, dependency_1.google.protobuf.Int32Value, 8) as dependency_1.google.protobuf.Int32Value;
        }
        set secret(value: dependency_1.google.protobuf.Int32Value) {
            pb_1.Message.setWrapperField(this, 8, value);
        }
        get has_secret() {
            return pb_1.Message.getField(this, 8) != null;
        }
        get is_live() {
            return pb_1.Message.getFieldWithDefault(this, 9, false) as boolean;
        }
        set is_live(value: boolean) {
            pb_1.Message.setField(this, 9, value);
        }
        get num_players() {
            return pb_1.Message.getFieldWithDefault(this, 10, 0) as number;
        }
        set num_players(value: number) {
            pb_1.Message.setField(this, 10, value);
        }
        get max_players() {
            return pb_1.Message.getFieldWithDefault(this, 11, 0) as number;
        }
        set max_players(value: number) {
            pb_1.Message.setField(this, 11, value);
        }
        get random_seed() {
            return pb_1.Message.getFieldWithDefault(this, 12, 0) as number;
        }
        set random_seed(value: number) {
            pb_1.Message.setField(this, 12, value);
        }
        get created_by() {
            return pb_1.Message.getWrapperField(this, dependency_3.player.PlayerRef, 13) as dependency_3.player.PlayerRef;
        }
        set created_by(value: dependency_3.player.PlayerRef) {
            pb_1.Message.setWrapperField(this, 13, value);
        }
        get has_created_by() {
            return pb_1.Message.getField(this, 13) != null;
        }
        get started_at() {
            return pb_1.Message.getWrapperField(this, dependency_2.google.protobuf.Timestamp, 14) as dependency_2.google.protobuf.Timestamp;
        }
        set started_at(value: dependency_2.google.protobuf.Timestamp) {
            pb_1.Message.setWrapperField(this, 14, value);
        }
        get has_started_at() {
            return pb_1.Message.getField(this, 14) != null;
        }
        get ended_at() {
            return pb_1.Message.getWrapperField(this, dependency_2.google.protobuf.Timestamp, 15) as dependency_2.google.protobuf.Timestamp;
        }
        set ended_at(value: dependency_2.google.protobuf.Timestamp) {
            pb_1.Message.setWrapperField(this, 15, value);
        }
        get has_ended_at() {
            return pb_1.Message.getField(this, 15) != null;
        }
        get created_at() {
            return pb_1.Message.getWrapperField(this, dependency_2.google.protobuf.Timestamp, 16) as dependency_2.google.protobuf.Timestamp;
        }
        set created_at(value: dependency_2.google.protobuf.Timestamp) {
            pb_1.Message.setWrapperField(this, 16, value);
        }
        get has_created_at() {
            return pb_1.Message.getField(this, 16) != null;
        }
        get updated_at() {
            return pb_1.Message.getWrapperField(this, dependency_2.google.protobuf.Timestamp, 17) as dependency_2.google.protobuf.Timestamp;
        }
        set updated_at(value: dependency_2.google.protobuf.Timestamp) {
            pb_1.Message.setWrapperField(this, 17, value);
        }
        get has_updated_at() {
            return pb_1.Message.getField(this, 17) != null;
        }
        get mask_player_names() {
            return pb_1.Message.getFieldWithDefault(this, 18, false) as boolean;
        }
        set mask_player_names(value: boolean) {
            pb_1.Message.setField(this, 18, value);
        }
        get game_version() {
            return pb_1.Message.getWrapperField(this, dependency_1.google.protobuf.StringValue, 19) as dependency_1.google.protobuf.StringValue;
        }
        set game_version(value: dependency_1.google.protobuf.StringValue) {
            pb_1.Message.setWrapperField(this, 19, value);
        }
        get has_game_version() {
            return pb_1.Message.getField(this, 19) != null;
        }
        get enable_ping_equalizer() {
            return pb_1.Message.getFieldWithDefault(this, 20, false) as boolean;
        }
        set enable_ping_equalizer(value: boolean) {
            pb_1.Message.setField(this, 20, value);
        }
        get flo_tv_delay_override_secs() {
            return pb_1.Message.getWrapperField(this, dependency_1.google.protobuf.Int32Value, 21) as dependency_1.google.protobuf.Int32Value;
        }
        set flo_tv_delay_override_secs(value: dependency_1.google.protobuf.Int32Value) {
            pb_1.Message.setWrapperField(this, 21, value);
        }
        get has_flo_tv_delay_override_secs() {
            return pb_1.Message.getField(this, 21) != null;
        }
        static fromObject(data: {
            id?: number;
            name?: string;
            status?: GameStatus;
            map?: ReturnType<typeof Map.prototype.toObject>;
            slots?: ReturnType<typeof Slot.prototype.toObject>[];
            node?: ReturnType<typeof dependency_4.node.Node.prototype.toObject>;
            is_private?: boolean;
            secret?: ReturnType<typeof dependency_1.google.protobuf.Int32Value.prototype.toObject>;
            is_live?: boolean;
            num_players?: number;
            max_players?: number;
            random_seed?: number;
            created_by?: ReturnType<typeof dependency_3.player.PlayerRef.prototype.toObject>;
            started_at?: ReturnType<typeof dependency_2.google.protobuf.Timestamp.prototype.toObject>;
            ended_at?: ReturnType<typeof dependency_2.google.protobuf.Timestamp.prototype.toObject>;
            created_at?: ReturnType<typeof dependency_2.google.protobuf.Timestamp.prototype.toObject>;
            updated_at?: ReturnType<typeof dependency_2.google.protobuf.Timestamp.prototype.toObject>;
            mask_player_names?: boolean;
            game_version?: ReturnType<typeof dependency_1.google.protobuf.StringValue.prototype.toObject>;
            enable_ping_equalizer?: boolean;
            flo_tv_delay_override_secs?: ReturnType<typeof dependency_1.google.protobuf.Int32Value.prototype.toObject>;
        }): Game {
            const message = new Game({});
            if (data.id != null) {
                message.id = data.id;
            }
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.status != null) {
                message.status = data.status;
            }
            if (data.map != null) {
                message.map = Map.fromObject(data.map);
            }
            if (data.slots != null) {
                message.slots = data.slots.map(item => Slot.fromObject(item));
            }
            if (data.node != null) {
                message.node = dependency_4.node.Node.fromObject(data.node);
            }
            if (data.is_private != null) {
                message.is_private = data.is_private;
            }
            if (data.secret != null) {
                message.secret = dependency_1.google.protobuf.Int32Value.fromObject(data.secret);
            }
            if (data.is_live != null) {
                message.is_live = data.is_live;
            }
            if (data.num_players != null) {
                message.num_players = data.num_players;
            }
            if (data.max_players != null) {
                message.max_players = data.max_players;
            }
            if (data.random_seed != null) {
                message.random_seed = data.random_seed;
            }
            if (data.created_by != null) {
                message.created_by = dependency_3.player.PlayerRef.fromObject(data.created_by);
            }
            if (data.started_at != null) {
                message.started_at = dependency_2.google.protobuf.Timestamp.fromObject(data.started_at);
            }
            if (data.ended_at != null) {
                message.ended_at = dependency_2.google.protobuf.Timestamp.fromObject(data.ended_at);
            }
            if (data.created_at != null) {
                message.created_at = dependency_2.google.protobuf.Timestamp.fromObject(data.created_at);
            }
            if (data.updated_at != null) {
                message.updated_at = dependency_2.google.protobuf.Timestamp.fromObject(data.updated_at);
            }
            if (data.mask_player_names != null) {
                message.mask_player_names = data.mask_player_names;
            }
            if (data.game_version != null) {
                message.game_version = dependency_1.google.protobuf.StringValue.fromObject(data.game_version);
            }
            if (data.enable_ping_equalizer != null) {
                message.enable_ping_equalizer = data.enable_ping_equalizer;
            }
            if (data.flo_tv_delay_override_secs != null) {
                message.flo_tv_delay_override_secs = dependency_1.google.protobuf.Int32Value.fromObject(data.flo_tv_delay_override_secs);
            }
            return message;
        }
        toObject() {
            const data: {
                id?: number;
                name?: string;
                status?: GameStatus;
                map?: ReturnType<typeof Map.prototype.toObject>;
                slots?: ReturnType<typeof Slot.prototype.toObject>[];
                node?: ReturnType<typeof dependency_4.node.Node.prototype.toObject>;
                is_private?: boolean;
                secret?: ReturnType<typeof dependency_1.google.protobuf.Int32Value.prototype.toObject>;
                is_live?: boolean;
                num_players?: number;
                max_players?: number;
                random_seed?: number;
                created_by?: ReturnType<typeof dependency_3.player.PlayerRef.prototype.toObject>;
                started_at?: ReturnType<typeof dependency_2.google.protobuf.Timestamp.prototype.toObject>;
                ended_at?: ReturnType<typeof dependency_2.google.protobuf.Timestamp.prototype.toObject>;
                created_at?: ReturnType<typeof dependency_2.google.protobuf.Timestamp.prototype.toObject>;
                updated_at?: ReturnType<typeof dependency_2.google.protobuf.Timestamp.prototype.toObject>;
                mask_player_names?: boolean;
                game_version?: ReturnType<typeof dependency_1.google.protobuf.StringValue.prototype.toObject>;
                enable_ping_equalizer?: boolean;
                flo_tv_delay_override_secs?: ReturnType<typeof dependency_1.google.protobuf.Int32Value.prototype.toObject>;
            } = {};
            if (this.id != null) {
                data.id = this.id;
            }
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.status != null) {
                data.status = this.status;
            }
            if (this.map != null) {
                data.map = this.map.toObject();
            }
            if (this.slots != null) {
                data.slots = this.slots.map((item: Slot) => item.toObject());
            }
            if (this.node != null) {
                data.node = this.node.toObject();
            }
            if (this.is_private != null) {
                data.is_private = this.is_private;
            }
            if (this.secret != null) {
                data.secret = this.secret.toObject();
            }
            if (this.is_live != null) {
                data.is_live = this.is_live;
            }
            if (this.num_players != null) {
                data.num_players = this.num_players;
            }
            if (this.max_players != null) {
                data.max_players = this.max_players;
            }
            if (this.random_seed != null) {
                data.random_seed = this.random_seed;
            }
            if (this.created_by != null) {
                data.created_by = this.created_by.toObject();
            }
            if (this.started_at != null) {
                data.started_at = this.started_at.toObject();
            }
            if (this.ended_at != null) {
                data.ended_at = this.ended_at.toObject();
            }
            if (this.created_at != null) {
                data.created_at = this.created_at.toObject();
            }
            if (this.updated_at != null) {
                data.updated_at = this.updated_at.toObject();
            }
            if (this.mask_player_names != null) {
                data.mask_player_names = this.mask_player_names;
            }
            if (this.game_version != null) {
                data.game_version = this.game_version.toObject();
            }
            if (this.enable_ping_equalizer != null) {
                data.enable_ping_equalizer = this.enable_ping_equalizer;
            }
            if (this.flo_tv_delay_override_secs != null) {
                data.flo_tv_delay_override_secs = this.flo_tv_delay_override_secs.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.id != 0)
                writer.writeInt32(1, this.id);
            if (this.name.length)
                writer.writeString(2, this.name);
            if (this.status != GameStatus.GameStatusPreparing)
                writer.writeEnum(3, this.status);
            if (this.has_map)
                writer.writeMessage(4, this.map, () => this.map.serialize(writer));
            if (this.slots.length)
                writer.writeRepeatedMessage(5, this.slots, (item: Slot) => item.serialize(writer));
            if (this.has_node)
                writer.writeMessage(6, this.node, () => this.node.serialize(writer));
            if (this.is_private != false)
                writer.writeBool(7, this.is_private);
            if (this.has_secret)
                writer.writeMessage(8, this.secret, () => this.secret.serialize(writer));
            if (this.is_live != false)
                writer.writeBool(9, this.is_live);
            if (this.num_players != 0)
                writer.writeInt32(10, this.num_players);
            if (this.max_players != 0)
                writer.writeInt32(11, this.max_players);
            if (this.random_seed != 0)
                writer.writeInt32(12, this.random_seed);
            if (this.has_created_by)
                writer.writeMessage(13, this.created_by, () => this.created_by.serialize(writer));
            if (this.has_started_at)
                writer.writeMessage(14, this.started_at, () => this.started_at.serialize(writer));
            if (this.has_ended_at)
                writer.writeMessage(15, this.ended_at, () => this.ended_at.serialize(writer));
            if (this.has_created_at)
                writer.writeMessage(16, this.created_at, () => this.created_at.serialize(writer));
            if (this.has_updated_at)
                writer.writeMessage(17, this.updated_at, () => this.updated_at.serialize(writer));
            if (this.mask_player_names != false)
                writer.writeBool(18, this.mask_player_names);
            if (this.has_game_version)
                writer.writeMessage(19, this.game_version, () => this.game_version.serialize(writer));
            if (this.enable_ping_equalizer != false)
                writer.writeBool(20, this.enable_ping_equalizer);
            if (this.has_flo_tv_delay_override_secs)
                writer.writeMessage(21, this.flo_tv_delay_override_secs, () => this.flo_tv_delay_override_secs.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Game {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Game();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.id = reader.readInt32();
                        break;
                    case 2:
                        message.name = reader.readString();
                        break;
                    case 3:
                        message.status = reader.readEnum();
                        break;
                    case 4:
                        reader.readMessage(message.map, () => message.map = Map.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.slots, () => pb_1.Message.addToRepeatedWrapperField(message, 5, Slot.deserialize(reader), Slot));
                        break;
                    case 6:
                        reader.readMessage(message.node, () => message.node = dependency_4.node.Node.deserialize(reader));
                        break;
                    case 7:
                        message.is_private = reader.readBool();
                        break;
                    case 8:
                        reader.readMessage(message.secret, () => message.secret = dependency_1.google.protobuf.Int32Value.deserialize(reader));
                        break;
                    case 9:
                        message.is_live = reader.readBool();
                        break;
                    case 10:
                        message.num_players = reader.readInt32();
                        break;
                    case 11:
                        message.max_players = reader.readInt32();
                        break;
                    case 12:
                        message.random_seed = reader.readInt32();
                        break;
                    case 13:
                        reader.readMessage(message.created_by, () => message.created_by = dependency_3.player.PlayerRef.deserialize(reader));
                        break;
                    case 14:
                        reader.readMessage(message.started_at, () => message.started_at = dependency_2.google.protobuf.Timestamp.deserialize(reader));
                        break;
                    case 15:
                        reader.readMessage(message.ended_at, () => message.ended_at = dependency_2.google.protobuf.Timestamp.deserialize(reader));
                        break;
                    case 16:
                        reader.readMessage(message.created_at, () => message.created_at = dependency_2.google.protobuf.Timestamp.deserialize(reader));
                        break;
                    case 17:
                        reader.readMessage(message.updated_at, () => message.updated_at = dependency_2.google.protobuf.Timestamp.deserialize(reader));
                        break;
                    case 18:
                        message.mask_player_names = reader.readBool();
                        break;
                    case 19:
                        reader.readMessage(message.game_version, () => message.game_version = dependency_1.google.protobuf.StringValue.deserialize(reader));
                        break;
                    case 20:
                        message.enable_ping_equalizer = reader.readBool();
                        break;
                    case 21:
                        reader.readMessage(message.flo_tv_delay_override_secs, () => message.flo_tv_delay_override_secs = dependency_1.google.protobuf.Int32Value.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Game {
            return Game.deserialize(bytes);
        }
    }
    export class GameEntry extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            id?: number;
            name?: string;
            map_name?: string;
            status?: GameStatus;
            is_private?: boolean;
            is_live?: boolean;
            num_players?: number;
            max_players?: number;
            node?: dependency_4.node.Node;
            created_by?: dependency_3.player.PlayerRef;
            started_at?: dependency_2.google.protobuf.Timestamp;
            ended_at?: dependency_2.google.protobuf.Timestamp;
            created_at?: dependency_2.google.protobuf.Timestamp;
            updated_at?: dependency_2.google.protobuf.Timestamp;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("map_name" in data && data.map_name != undefined) {
                    this.map_name = data.map_name;
                }
                if ("status" in data && data.status != undefined) {
                    this.status = data.status;
                }
                if ("is_private" in data && data.is_private != undefined) {
                    this.is_private = data.is_private;
                }
                if ("is_live" in data && data.is_live != undefined) {
                    this.is_live = data.is_live;
                }
                if ("num_players" in data && data.num_players != undefined) {
                    this.num_players = data.num_players;
                }
                if ("max_players" in data && data.max_players != undefined) {
                    this.max_players = data.max_players;
                }
                if ("node" in data && data.node != undefined) {
                    this.node = data.node;
                }
                if ("created_by" in data && data.created_by != undefined) {
                    this.created_by = data.created_by;
                }
                if ("started_at" in data && data.started_at != undefined) {
                    this.started_at = data.started_at;
                }
                if ("ended_at" in data && data.ended_at != undefined) {
                    this.ended_at = data.ended_at;
                }
                if ("created_at" in data && data.created_at != undefined) {
                    this.created_at = data.created_at;
                }
                if ("updated_at" in data && data.updated_at != undefined) {
                    this.updated_at = data.updated_at;
                }
            }
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set id(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get map_name() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set map_name(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get status() {
            return pb_1.Message.getFieldWithDefault(this, 4, GameStatus.GameStatusPreparing) as GameStatus;
        }
        set status(value: GameStatus) {
            pb_1.Message.setField(this, 4, value);
        }
        get is_private() {
            return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
        }
        set is_private(value: boolean) {
            pb_1.Message.setField(this, 5, value);
        }
        get is_live() {
            return pb_1.Message.getFieldWithDefault(this, 6, false) as boolean;
        }
        set is_live(value: boolean) {
            pb_1.Message.setField(this, 6, value);
        }
        get num_players() {
            return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
        }
        set num_players(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get max_players() {
            return pb_1.Message.getFieldWithDefault(this, 8, 0) as number;
        }
        set max_players(value: number) {
            pb_1.Message.setField(this, 8, value);
        }
        get node() {
            return pb_1.Message.getWrapperField(this, dependency_4.node.Node, 9) as dependency_4.node.Node;
        }
        set node(value: dependency_4.node.Node) {
            pb_1.Message.setWrapperField(this, 9, value);
        }
        get has_node() {
            return pb_1.Message.getField(this, 9) != null;
        }
        get created_by() {
            return pb_1.Message.getWrapperField(this, dependency_3.player.PlayerRef, 10) as dependency_3.player.PlayerRef;
        }
        set created_by(value: dependency_3.player.PlayerRef) {
            pb_1.Message.setWrapperField(this, 10, value);
        }
        get has_created_by() {
            return pb_1.Message.getField(this, 10) != null;
        }
        get started_at() {
            return pb_1.Message.getWrapperField(this, dependency_2.google.protobuf.Timestamp, 11) as dependency_2.google.protobuf.Timestamp;
        }
        set started_at(value: dependency_2.google.protobuf.Timestamp) {
            pb_1.Message.setWrapperField(this, 11, value);
        }
        get has_started_at() {
            return pb_1.Message.getField(this, 11) != null;
        }
        get ended_at() {
            return pb_1.Message.getWrapperField(this, dependency_2.google.protobuf.Timestamp, 12) as dependency_2.google.protobuf.Timestamp;
        }
        set ended_at(value: dependency_2.google.protobuf.Timestamp) {
            pb_1.Message.setWrapperField(this, 12, value);
        }
        get has_ended_at() {
            return pb_1.Message.getField(this, 12) != null;
        }
        get created_at() {
            return pb_1.Message.getWrapperField(this, dependency_2.google.protobuf.Timestamp, 13) as dependency_2.google.protobuf.Timestamp;
        }
        set created_at(value: dependency_2.google.protobuf.Timestamp) {
            pb_1.Message.setWrapperField(this, 13, value);
        }
        get has_created_at() {
            return pb_1.Message.getField(this, 13) != null;
        }
        get updated_at() {
            return pb_1.Message.getWrapperField(this, dependency_2.google.protobuf.Timestamp, 14) as dependency_2.google.protobuf.Timestamp;
        }
        set updated_at(value: dependency_2.google.protobuf.Timestamp) {
            pb_1.Message.setWrapperField(this, 14, value);
        }
        get has_updated_at() {
            return pb_1.Message.getField(this, 14) != null;
        }
        static fromObject(data: {
            id?: number;
            name?: string;
            map_name?: string;
            status?: GameStatus;
            is_private?: boolean;
            is_live?: boolean;
            num_players?: number;
            max_players?: number;
            node?: ReturnType<typeof dependency_4.node.Node.prototype.toObject>;
            created_by?: ReturnType<typeof dependency_3.player.PlayerRef.prototype.toObject>;
            started_at?: ReturnType<typeof dependency_2.google.protobuf.Timestamp.prototype.toObject>;
            ended_at?: ReturnType<typeof dependency_2.google.protobuf.Timestamp.prototype.toObject>;
            created_at?: ReturnType<typeof dependency_2.google.protobuf.Timestamp.prototype.toObject>;
            updated_at?: ReturnType<typeof dependency_2.google.protobuf.Timestamp.prototype.toObject>;
        }): GameEntry {
            const message = new GameEntry({});
            if (data.id != null) {
                message.id = data.id;
            }
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.map_name != null) {
                message.map_name = data.map_name;
            }
            if (data.status != null) {
                message.status = data.status;
            }
            if (data.is_private != null) {
                message.is_private = data.is_private;
            }
            if (data.is_live != null) {
                message.is_live = data.is_live;
            }
            if (data.num_players != null) {
                message.num_players = data.num_players;
            }
            if (data.max_players != null) {
                message.max_players = data.max_players;
            }
            if (data.node != null) {
                message.node = dependency_4.node.Node.fromObject(data.node);
            }
            if (data.created_by != null) {
                message.created_by = dependency_3.player.PlayerRef.fromObject(data.created_by);
            }
            if (data.started_at != null) {
                message.started_at = dependency_2.google.protobuf.Timestamp.fromObject(data.started_at);
            }
            if (data.ended_at != null) {
                message.ended_at = dependency_2.google.protobuf.Timestamp.fromObject(data.ended_at);
            }
            if (data.created_at != null) {
                message.created_at = dependency_2.google.protobuf.Timestamp.fromObject(data.created_at);
            }
            if (data.updated_at != null) {
                message.updated_at = dependency_2.google.protobuf.Timestamp.fromObject(data.updated_at);
            }
            return message;
        }
        toObject() {
            const data: {
                id?: number;
                name?: string;
                map_name?: string;
                status?: GameStatus;
                is_private?: boolean;
                is_live?: boolean;
                num_players?: number;
                max_players?: number;
                node?: ReturnType<typeof dependency_4.node.Node.prototype.toObject>;
                created_by?: ReturnType<typeof dependency_3.player.PlayerRef.prototype.toObject>;
                started_at?: ReturnType<typeof dependency_2.google.protobuf.Timestamp.prototype.toObject>;
                ended_at?: ReturnType<typeof dependency_2.google.protobuf.Timestamp.prototype.toObject>;
                created_at?: ReturnType<typeof dependency_2.google.protobuf.Timestamp.prototype.toObject>;
                updated_at?: ReturnType<typeof dependency_2.google.protobuf.Timestamp.prototype.toObject>;
            } = {};
            if (this.id != null) {
                data.id = this.id;
            }
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.map_name != null) {
                data.map_name = this.map_name;
            }
            if (this.status != null) {
                data.status = this.status;
            }
            if (this.is_private != null) {
                data.is_private = this.is_private;
            }
            if (this.is_live != null) {
                data.is_live = this.is_live;
            }
            if (this.num_players != null) {
                data.num_players = this.num_players;
            }
            if (this.max_players != null) {
                data.max_players = this.max_players;
            }
            if (this.node != null) {
                data.node = this.node.toObject();
            }
            if (this.created_by != null) {
                data.created_by = this.created_by.toObject();
            }
            if (this.started_at != null) {
                data.started_at = this.started_at.toObject();
            }
            if (this.ended_at != null) {
                data.ended_at = this.ended_at.toObject();
            }
            if (this.created_at != null) {
                data.created_at = this.created_at.toObject();
            }
            if (this.updated_at != null) {
                data.updated_at = this.updated_at.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.id != 0)
                writer.writeInt32(1, this.id);
            if (this.name.length)
                writer.writeString(2, this.name);
            if (this.map_name.length)
                writer.writeString(3, this.map_name);
            if (this.status != GameStatus.GameStatusPreparing)
                writer.writeEnum(4, this.status);
            if (this.is_private != false)
                writer.writeBool(5, this.is_private);
            if (this.is_live != false)
                writer.writeBool(6, this.is_live);
            if (this.num_players != 0)
                writer.writeInt32(7, this.num_players);
            if (this.max_players != 0)
                writer.writeInt32(8, this.max_players);
            if (this.has_node)
                writer.writeMessage(9, this.node, () => this.node.serialize(writer));
            if (this.has_created_by)
                writer.writeMessage(10, this.created_by, () => this.created_by.serialize(writer));
            if (this.has_started_at)
                writer.writeMessage(11, this.started_at, () => this.started_at.serialize(writer));
            if (this.has_ended_at)
                writer.writeMessage(12, this.ended_at, () => this.ended_at.serialize(writer));
            if (this.has_created_at)
                writer.writeMessage(13, this.created_at, () => this.created_at.serialize(writer));
            if (this.has_updated_at)
                writer.writeMessage(14, this.updated_at, () => this.updated_at.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GameEntry {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GameEntry();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.id = reader.readInt32();
                        break;
                    case 2:
                        message.name = reader.readString();
                        break;
                    case 3:
                        message.map_name = reader.readString();
                        break;
                    case 4:
                        message.status = reader.readEnum();
                        break;
                    case 5:
                        message.is_private = reader.readBool();
                        break;
                    case 6:
                        message.is_live = reader.readBool();
                        break;
                    case 7:
                        message.num_players = reader.readInt32();
                        break;
                    case 8:
                        message.max_players = reader.readInt32();
                        break;
                    case 9:
                        reader.readMessage(message.node, () => message.node = dependency_4.node.Node.deserialize(reader));
                        break;
                    case 10:
                        reader.readMessage(message.created_by, () => message.created_by = dependency_3.player.PlayerRef.deserialize(reader));
                        break;
                    case 11:
                        reader.readMessage(message.started_at, () => message.started_at = dependency_2.google.protobuf.Timestamp.deserialize(reader));
                        break;
                    case 12:
                        reader.readMessage(message.ended_at, () => message.ended_at = dependency_2.google.protobuf.Timestamp.deserialize(reader));
                        break;
                    case 13:
                        reader.readMessage(message.created_at, () => message.created_at = dependency_2.google.protobuf.Timestamp.deserialize(reader));
                        break;
                    case 14:
                        reader.readMessage(message.updated_at, () => message.updated_at = dependency_2.google.protobuf.Timestamp.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GameEntry {
            return GameEntry.deserialize(bytes);
        }
    }
    export class Slot extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            player?: dependency_3.player.PlayerRef;
            settings?: SlotSettings;
            client_status?: SlotClientStatus;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("player" in data && data.player != undefined) {
                    this.player = data.player;
                }
                if ("settings" in data && data.settings != undefined) {
                    this.settings = data.settings;
                }
                if ("client_status" in data && data.client_status != undefined) {
                    this.client_status = data.client_status;
                }
            }
        }
        get player() {
            return pb_1.Message.getWrapperField(this, dependency_3.player.PlayerRef, 2) as dependency_3.player.PlayerRef;
        }
        set player(value: dependency_3.player.PlayerRef) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_player() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get settings() {
            return pb_1.Message.getWrapperField(this, SlotSettings, 3) as SlotSettings;
        }
        set settings(value: SlotSettings) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_settings() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get client_status() {
            return pb_1.Message.getFieldWithDefault(this, 4, SlotClientStatus.SlotClientStatusPending) as SlotClientStatus;
        }
        set client_status(value: SlotClientStatus) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            player?: ReturnType<typeof dependency_3.player.PlayerRef.prototype.toObject>;
            settings?: ReturnType<typeof SlotSettings.prototype.toObject>;
            client_status?: SlotClientStatus;
        }): Slot {
            const message = new Slot({});
            if (data.player != null) {
                message.player = dependency_3.player.PlayerRef.fromObject(data.player);
            }
            if (data.settings != null) {
                message.settings = SlotSettings.fromObject(data.settings);
            }
            if (data.client_status != null) {
                message.client_status = data.client_status;
            }
            return message;
        }
        toObject() {
            const data: {
                player?: ReturnType<typeof dependency_3.player.PlayerRef.prototype.toObject>;
                settings?: ReturnType<typeof SlotSettings.prototype.toObject>;
                client_status?: SlotClientStatus;
            } = {};
            if (this.player != null) {
                data.player = this.player.toObject();
            }
            if (this.settings != null) {
                data.settings = this.settings.toObject();
            }
            if (this.client_status != null) {
                data.client_status = this.client_status;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_player)
                writer.writeMessage(2, this.player, () => this.player.serialize(writer));
            if (this.has_settings)
                writer.writeMessage(3, this.settings, () => this.settings.serialize(writer));
            if (this.client_status != SlotClientStatus.SlotClientStatusPending)
                writer.writeEnum(4, this.client_status);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Slot {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Slot();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 2:
                        reader.readMessage(message.player, () => message.player = dependency_3.player.PlayerRef.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.settings, () => message.settings = SlotSettings.deserialize(reader));
                        break;
                    case 4:
                        message.client_status = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Slot {
            return Slot.deserialize(bytes);
        }
    }
    export class SlotSettings extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            team?: number;
            color?: number;
            computer?: Computer;
            handicap?: number;
            status?: SlotStatus;
            race?: Race;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("team" in data && data.team != undefined) {
                    this.team = data.team;
                }
                if ("color" in data && data.color != undefined) {
                    this.color = data.color;
                }
                if ("computer" in data && data.computer != undefined) {
                    this.computer = data.computer;
                }
                if ("handicap" in data && data.handicap != undefined) {
                    this.handicap = data.handicap;
                }
                if ("status" in data && data.status != undefined) {
                    this.status = data.status;
                }
                if ("race" in data && data.race != undefined) {
                    this.race = data.race;
                }
            }
        }
        get team() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set team(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get color() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set color(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get computer() {
            return pb_1.Message.getFieldWithDefault(this, 3, Computer.ComputerEasy) as Computer;
        }
        set computer(value: Computer) {
            pb_1.Message.setField(this, 3, value);
        }
        get handicap() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set handicap(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get status() {
            return pb_1.Message.getFieldWithDefault(this, 5, SlotStatus.SlotStatusOpen) as SlotStatus;
        }
        set status(value: SlotStatus) {
            pb_1.Message.setField(this, 5, value);
        }
        get race() {
            return pb_1.Message.getFieldWithDefault(this, 6, Race.RaceHuman) as Race;
        }
        set race(value: Race) {
            pb_1.Message.setField(this, 6, value);
        }
        static fromObject(data: {
            team?: number;
            color?: number;
            computer?: Computer;
            handicap?: number;
            status?: SlotStatus;
            race?: Race;
        }): SlotSettings {
            const message = new SlotSettings({});
            if (data.team != null) {
                message.team = data.team;
            }
            if (data.color != null) {
                message.color = data.color;
            }
            if (data.computer != null) {
                message.computer = data.computer;
            }
            if (data.handicap != null) {
                message.handicap = data.handicap;
            }
            if (data.status != null) {
                message.status = data.status;
            }
            if (data.race != null) {
                message.race = data.race;
            }
            return message;
        }
        toObject() {
            const data: {
                team?: number;
                color?: number;
                computer?: Computer;
                handicap?: number;
                status?: SlotStatus;
                race?: Race;
            } = {};
            if (this.team != null) {
                data.team = this.team;
            }
            if (this.color != null) {
                data.color = this.color;
            }
            if (this.computer != null) {
                data.computer = this.computer;
            }
            if (this.handicap != null) {
                data.handicap = this.handicap;
            }
            if (this.status != null) {
                data.status = this.status;
            }
            if (this.race != null) {
                data.race = this.race;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.team != 0)
                writer.writeInt32(1, this.team);
            if (this.color != 0)
                writer.writeInt32(2, this.color);
            if (this.computer != Computer.ComputerEasy)
                writer.writeEnum(3, this.computer);
            if (this.handicap != 0)
                writer.writeInt32(4, this.handicap);
            if (this.status != SlotStatus.SlotStatusOpen)
                writer.writeEnum(5, this.status);
            if (this.race != Race.RaceHuman)
                writer.writeEnum(6, this.race);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SlotSettings {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SlotSettings();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.team = reader.readInt32();
                        break;
                    case 2:
                        message.color = reader.readInt32();
                        break;
                    case 3:
                        message.computer = reader.readEnum();
                        break;
                    case 4:
                        message.handicap = reader.readInt32();
                        break;
                    case 5:
                        message.status = reader.readEnum();
                        break;
                    case 6:
                        message.race = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SlotSettings {
            return SlotSettings.deserialize(bytes);
        }
    }
    export class Map extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            sha1?: Uint8Array;
            checksum?: number;
            name?: string;
            description?: string;
            author?: string;
            path?: string;
            width?: number;
            height?: number;
            players?: MapPlayer[];
            forces?: MapForce[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [9, 10], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("sha1" in data && data.sha1 != undefined) {
                    this.sha1 = data.sha1;
                }
                if ("checksum" in data && data.checksum != undefined) {
                    this.checksum = data.checksum;
                }
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("description" in data && data.description != undefined) {
                    this.description = data.description;
                }
                if ("author" in data && data.author != undefined) {
                    this.author = data.author;
                }
                if ("path" in data && data.path != undefined) {
                    this.path = data.path;
                }
                if ("width" in data && data.width != undefined) {
                    this.width = data.width;
                }
                if ("height" in data && data.height != undefined) {
                    this.height = data.height;
                }
                if ("players" in data && data.players != undefined) {
                    this.players = data.players;
                }
                if ("forces" in data && data.forces != undefined) {
                    this.forces = data.forces;
                }
            }
        }
        get sha1() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array()) as Uint8Array;
        }
        set sha1(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get checksum() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set checksum(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get description() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set description(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get author() {
            return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
        }
        set author(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        get path() {
            return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
        }
        set path(value: string) {
            pb_1.Message.setField(this, 6, value);
        }
        get width() {
            return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
        }
        set width(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get height() {
            return pb_1.Message.getFieldWithDefault(this, 8, 0) as number;
        }
        set height(value: number) {
            pb_1.Message.setField(this, 8, value);
        }
        get players() {
            return pb_1.Message.getRepeatedWrapperField(this, MapPlayer, 9) as MapPlayer[];
        }
        set players(value: MapPlayer[]) {
            pb_1.Message.setRepeatedWrapperField(this, 9, value);
        }
        get forces() {
            return pb_1.Message.getRepeatedWrapperField(this, MapForce, 10) as MapForce[];
        }
        set forces(value: MapForce[]) {
            pb_1.Message.setRepeatedWrapperField(this, 10, value);
        }
        static fromObject(data: {
            sha1?: Uint8Array;
            checksum?: number;
            name?: string;
            description?: string;
            author?: string;
            path?: string;
            width?: number;
            height?: number;
            players?: ReturnType<typeof MapPlayer.prototype.toObject>[];
            forces?: ReturnType<typeof MapForce.prototype.toObject>[];
        }): Map {
            const message = new Map({});
            if (data.sha1 != null) {
                message.sha1 = data.sha1;
            }
            if (data.checksum != null) {
                message.checksum = data.checksum;
            }
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.description != null) {
                message.description = data.description;
            }
            if (data.author != null) {
                message.author = data.author;
            }
            if (data.path != null) {
                message.path = data.path;
            }
            if (data.width != null) {
                message.width = data.width;
            }
            if (data.height != null) {
                message.height = data.height;
            }
            if (data.players != null) {
                message.players = data.players.map(item => MapPlayer.fromObject(item));
            }
            if (data.forces != null) {
                message.forces = data.forces.map(item => MapForce.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                sha1?: Uint8Array;
                checksum?: number;
                name?: string;
                description?: string;
                author?: string;
                path?: string;
                width?: number;
                height?: number;
                players?: ReturnType<typeof MapPlayer.prototype.toObject>[];
                forces?: ReturnType<typeof MapForce.prototype.toObject>[];
            } = {};
            if (this.sha1 != null) {
                data.sha1 = this.sha1;
            }
            if (this.checksum != null) {
                data.checksum = this.checksum;
            }
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.description != null) {
                data.description = this.description;
            }
            if (this.author != null) {
                data.author = this.author;
            }
            if (this.path != null) {
                data.path = this.path;
            }
            if (this.width != null) {
                data.width = this.width;
            }
            if (this.height != null) {
                data.height = this.height;
            }
            if (this.players != null) {
                data.players = this.players.map((item: MapPlayer) => item.toObject());
            }
            if (this.forces != null) {
                data.forces = this.forces.map((item: MapForce) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.sha1.length)
                writer.writeBytes(1, this.sha1);
            if (this.checksum != 0)
                writer.writeUint32(2, this.checksum);
            if (this.name.length)
                writer.writeString(3, this.name);
            if (this.description.length)
                writer.writeString(4, this.description);
            if (this.author.length)
                writer.writeString(5, this.author);
            if (this.path.length)
                writer.writeString(6, this.path);
            if (this.width != 0)
                writer.writeUint32(7, this.width);
            if (this.height != 0)
                writer.writeUint32(8, this.height);
            if (this.players.length)
                writer.writeRepeatedMessage(9, this.players, (item: MapPlayer) => item.serialize(writer));
            if (this.forces.length)
                writer.writeRepeatedMessage(10, this.forces, (item: MapForce) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Map {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Map();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.sha1 = reader.readBytes();
                        break;
                    case 2:
                        message.checksum = reader.readUint32();
                        break;
                    case 3:
                        message.name = reader.readString();
                        break;
                    case 4:
                        message.description = reader.readString();
                        break;
                    case 5:
                        message.author = reader.readString();
                        break;
                    case 6:
                        message.path = reader.readString();
                        break;
                    case 7:
                        message.width = reader.readUint32();
                        break;
                    case 8:
                        message.height = reader.readUint32();
                        break;
                    case 9:
                        reader.readMessage(message.players, () => pb_1.Message.addToRepeatedWrapperField(message, 9, MapPlayer.deserialize(reader), MapPlayer));
                        break;
                    case 10:
                        reader.readMessage(message.forces, () => pb_1.Message.addToRepeatedWrapperField(message, 10, MapForce.deserialize(reader), MapForce));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Map {
            return Map.deserialize(bytes);
        }
    }
    export class MapPlayer extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            type?: number;
            race?: number;
            flags?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("race" in data && data.race != undefined) {
                    this.race = data.race;
                }
                if ("flags" in data && data.flags != undefined) {
                    this.flags = data.flags;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set type(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get race() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set race(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get flags() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set flags(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            name?: string;
            type?: number;
            race?: number;
            flags?: number;
        }): MapPlayer {
            const message = new MapPlayer({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.race != null) {
                message.race = data.race;
            }
            if (data.flags != null) {
                message.flags = data.flags;
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                type?: number;
                race?: number;
                flags?: number;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.race != null) {
                data.race = this.race;
            }
            if (this.flags != null) {
                data.flags = this.flags;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeString(1, this.name);
            if (this.type != 0)
                writer.writeUint32(2, this.type);
            if (this.race != 0)
                writer.writeUint32(3, this.race);
            if (this.flags != 0)
                writer.writeUint32(4, this.flags);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MapPlayer {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MapPlayer();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        message.type = reader.readUint32();
                        break;
                    case 3:
                        message.race = reader.readUint32();
                        break;
                    case 4:
                        message.flags = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MapPlayer {
            return MapPlayer.deserialize(bytes);
        }
    }
    export class MapForce extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            flags?: number;
            player_set?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("flags" in data && data.flags != undefined) {
                    this.flags = data.flags;
                }
                if ("player_set" in data && data.player_set != undefined) {
                    this.player_set = data.player_set;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get flags() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set flags(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get player_set() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set player_set(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            name?: string;
            flags?: number;
            player_set?: number;
        }): MapForce {
            const message = new MapForce({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.flags != null) {
                message.flags = data.flags;
            }
            if (data.player_set != null) {
                message.player_set = data.player_set;
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                flags?: number;
                player_set?: number;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.flags != null) {
                data.flags = this.flags;
            }
            if (this.player_set != null) {
                data.player_set = this.player_set;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeString(1, this.name);
            if (this.flags != 0)
                writer.writeUint32(2, this.flags);
            if (this.player_set != 0)
                writer.writeUint32(3, this.player_set);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MapForce {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MapForce();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        message.flags = reader.readUint32();
                        break;
                    case 3:
                        message.player_set = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MapForce {
            return MapForce.deserialize(bytes);
        }
    }
    export class MapChecksumImportItem extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            sha1?: string;
            checksum?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("sha1" in data && data.sha1 != undefined) {
                    this.sha1 = data.sha1;
                }
                if ("checksum" in data && data.checksum != undefined) {
                    this.checksum = data.checksum;
                }
            }
        }
        get sha1() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set sha1(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get checksum() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set checksum(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            sha1?: string;
            checksum?: number;
        }): MapChecksumImportItem {
            const message = new MapChecksumImportItem({});
            if (data.sha1 != null) {
                message.sha1 = data.sha1;
            }
            if (data.checksum != null) {
                message.checksum = data.checksum;
            }
            return message;
        }
        toObject() {
            const data: {
                sha1?: string;
                checksum?: number;
            } = {};
            if (this.sha1 != null) {
                data.sha1 = this.sha1;
            }
            if (this.checksum != null) {
                data.checksum = this.checksum;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.sha1.length)
                writer.writeString(1, this.sha1);
            if (this.checksum != 0)
                writer.writeUint32(2, this.checksum);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MapChecksumImportItem {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MapChecksumImportItem();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.sha1 = reader.readString();
                        break;
                    case 2:
                        message.checksum = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MapChecksumImportItem {
            return MapChecksumImportItem.deserialize(bytes);
        }
    }
}
